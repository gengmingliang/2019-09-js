<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    /*
        类     实例        原型对象
        人类   特朗普      公用属性

    js天生自带的类  function array object(基类) string number···
    自定义类  function tab(){}

    自带类的原型上的属性 可以修改但是原型不能被覆盖

    prototype  __proto__  constructor

    //原型就是一个堆内存(对象)
    每一个函数(类)都天生自带一个prototype的属性 指向自己的原型；
    每一个对象(实例)都天生自带一个__proto__的属性 指向所属类的原型
    每一个默认的原型上 都有一个constructor属性 指向构造函数本身

    原型链：属性的查找机制：现在自己身上查找  没有的话就通过__proto__接着向上级原型查找
            再没有就接着通过__proto__向上级原型查找 直到找到基类的原型，再没有 拿到的就是undefined
    
    查看一个属性是否是私有属性：hasownproperty('eat')
    //封装一个判断公用属性的方法：这个方法需要放在基类的原型上 需要注意首先是他的属性 然后还不能是私有属性
    //在原型上封装的方法： 里边的this 需要保证的是该类的实例

    */
    Object.prototype.eat = function () {
        // this
    }
    var a = []
    console.log(a.eat)
    console.log('eat' in a)

    Number.prototype.plus = function (a) {
        return this+a
    }
    Number.prototype.minus = function (a) {
        return this-a
    }
    var n = 20
    var m = n.plus(10).minus(5)
    console.log(m)//20+10-5

    function fn(num){
        this.x=this.y=num
    }
    fn.prototype ={
        x:20,
        sum:function(){
            console.log(this.x+this.y)
        }
    }
    let f =new fn(10)//f={x:10,y:10}
    console.log(f.sum===fn.prototype.sum)
    f.sum()//20
    fn.prototype.sum()//NaN
    console.log(f.constructor)//object
</script>
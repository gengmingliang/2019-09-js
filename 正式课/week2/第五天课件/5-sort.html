<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>
    <ul class="box">
        <li>姓名是<span>小明</span>年龄是<span>20</span></li>
        <li>姓名是<span>小明</span>年龄是<span>20</span></li>
        <li>姓名是<span>小明</span>年龄是<span>20</span></li>
    </ul>
</body>

</html>
<script>
    let box = document.querySelector('.box')
    let ary = [
        { name: '小明1', age: 10 },
        { name: '小明2', age: 20 },
        { name: '小明3', age: 30 },
        { name: '小明4', age: 40 }
    ]
    let [a, , , , b] = [1, 2, 3, 4, 5]//数组的解构赋值 按照位置决定
    let { x, y, z } = { x: 12, a: 123, v: 345, y: 666 }//x=12，y=666 z=undefined 对象的解构是按照属性名对应的
    function renderHtml(ary) {
        var str = ''
        ary.forEach((item) => {
            let { name, age } = item
            str += `<li>姓名是<span>${item.name}</span>年龄是<span>${item.age}</span></li>`
        })
        box.innerHTML = str
    }
    var olis = document.getElementsByTagName('li')
    var olis2 = document.querySelectorAll('li')
    console.log(olis, olis2)
    renderHtml(ary)
    console.log(olis, olis2)

    //olis是更新之后的集合
    let arr = [...olis]
    arr.sort((a, b) => {
        let aName = a.getElementsByTagName('span')[0].innerHTML
        let bName = b.getElementsByTagName('span')[0].innerHTML
        return bName.localeCompare(aName)
    })
    console.log(arr)//arr是按照姓名排好序的数组因为这些元素都是在页面上已经存在的 所以append只会改变位置 不会新增
    arr.forEach(item=>{
        box.appendChild(item)//
    })

    //DOM的回流和重绘
    // 只要改动dom的结果或者元素的位置 都会引发dom回流 回流：浏览器需要重新渲染一遍解构
    // 重绘：只是让页面重新渲染一下css样式 比如改变字体颜色 改变背景图等等
</script>
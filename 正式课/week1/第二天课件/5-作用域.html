<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>

<body>

</body>

</html>
<script>
    /*
        作用域：起作用的区域
        js中的作用域 全局作用域 私有作用域
        js作用域就是指的一块栈内存

        栈内存 存储值类型 提供代码的运行环境
        堆内存 存储引用数据类型

        全局作用域：页面一打开就会形成一个全局作用域 一个页面只有一个全局作用域
        私有作用域：函数执行的时候会形成一个私有的作用域

        全局变量：在全局声明的变量叫做全局变量
        私有变量：在私有作用域声明的变量叫做私有变量 形参也是私有变量

        上级作用域：外层作用域 查找规律：上级作用域是谁，就看这个函数是在那个作用域定义的
        对于私有作用域中的某些变量 若没有在私有作用域中声明过 那么函数执行时 
        就会去上级作用域查找该变量 上级作用域若没有该变量则接着向上级查找，知道查找到全局作用域
        若仍没有 就报错
        作用域链 变量的查找机制 一直向上级作用域查找


        函数的执行过程：
            先开辟一个私有作用域（栈内存），然后设置一个形参赋值，再就是变量提升，然后代码从上到下执行
            函数中的私有变量有形参和在私有作用域中声明过的变量，其他的变量都是上级作用域的

        es6对let 和const声明的变量 多了一个块级作用域({})

    */
    var a = 12
    var f = function () {
        console.log(a)//undefined 存在变量提升所以导致它时undefined
        var a = 100
        console.log(a)//100
    }
    f()//在代码执行之前就有变量提升的这个阶段
    console.log(a)//12 这是全局的a和私有的a没有关系


    var b =10
    var f2 =function(){
        console.log(b)//10
        b=200
        console.log(b)//200
    }
    f2()
    console.log(b)//200

    var f3 =function(c){
        //let c =100
    }

    var f4 =function(){
        console.log(d)
        //暂时性死区：在let和const之前 不能使用他们声明的任何变量
        let d =100
    }
    f4()

    if(1<2){
        var e =12
        let g =13
    }
    console.log(e)
    console.log(g)
</script>
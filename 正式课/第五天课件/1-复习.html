<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    /*
        1、变量提升
        代码执行之前 先把用var和function关键字声明的变量提前声明，带var的只声明不定义，带function的既声明又定义，前提是不在块级作用域内部。

        暂时性死区
        在let和const声明的变量之上不能使用对应的变量，一使用就报错。

        2、堆栈内存
        栈内存存储值类型 提供代码的运行环境
        堆内存存储引用数据类型

        对象的存储过程：先开辟一个堆内存，然后把键值对一对一对的存到里面。存储完成之后，把地址赋给对应的变量。
        函数的存储过程：先开辟一个堆内存，然后把函数体当做字符串存储到该内存中，存储完成之后把地址给函数名

        作用域：都是栈内存 代码能够起作用的区域
        全局作用域 页面一打开就会形成一个全局作用域
        私有作用域 函数执行形成的作用域 函数执行的过程：开辟一个作用域 形参赋值 变量提升 代码执行
        块状作用域 es6特有的 针对let const才能起作用，对于var没有任何反应

        全局变量 全局作用域声明的变量
        私有变量 私有作用域声明的变量 对于函数来说还有一个形参

        var let const之间的区别？
        1、var可以重复声明let和const不能重复声明 let是变量 const是常量
        2、let const没有变量提升 存在暂时性死区
        3、let const能够识别块级作用域

        堆栈内存销毁：
            堆内存的销毁：谷歌浏览器会定期查看堆内存空间 把空间中没用的销毁
            栈内存的销毁：全局作用域的销毁：只有当页面关闭的时候才会关闭
                         私有作用域的销毁：只有当函数的返回值是一个引用数据类型的时候才不会被销毁

        闭包：一个不销毁的作用域 作用：1、保护私有变量不受外界的污染 2、存储值
        闭包有什么缺点？
        一个不销毁的作用域 用的次数多会造成内存泄漏

        this 函数的执行主体
        1、事件绑定中的this都是当前操作的元素
        2、自执行函数中的this是window
        3、一般函数执行时内部的this指向 看点 点前边是谁 this指的就是谁 其他的都是window
        
    */
</script>
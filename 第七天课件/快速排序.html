<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
    
</body>
</html>
<script>
    //递归：函数自己调用自己 使用递归的时候 一定要注意边界的问题
    function sum(a){
        if(a>2){
            return a
        }
        return a+sum(a+1)
    }
    var res=sum(1)
    console.log(res)

    //0-100的和
    function f(n){
        var t =0;
        for(var i =0;i<=n;i++){
            t+=1
        }return t
    }
    f(100)

    //递归的写法
    function f2(n){
        if(n<=0){
            return 0
        }
        return n +f2(n-1)
    }
    console.log(f2(100))

    function f3(n){
        if(n<=0){
            return 0
        }
        if(n%3==0||n%5==0){
            return n+f3(n-1)
        }else{
            return f3(n-1)
        }
    }
    console.log(f3(5))

    /*
        fn(arr) 把数组从中间分开 取中间的那个项 把比这个项小的放到一个数组 大的放到一个数组 对于这两个数组再去执行fn
    */
    function quickSort(arr) {
        // 边界
        if(arr.length<=1){
            return arr;
        }
        var n = parseInt(arr.length/2);
        var temp = arr.splice(n,1)[0];// arr.splice(n,1) 返回值是由 索引为n的这一项组成的新数组；我们用这一项， 所以加个索引0
        var left = [],
            right = [];// left 用来存储 比 temp小的那些项； right用来存储比temp大的那些项；
        for(var i=0; i < arr.length; i++){
            if(temp >= arr[i]){
                left.push(arr[i])
            }else{
                right.push(arr[i])
            }
        }   
        return quickSort(left).concat(temp,quickSort(right)) 
    }
    var ary = [23,34,12,54,23,6,7,42];
    var res = quickSort(ary);
    console.log(res);

</script>